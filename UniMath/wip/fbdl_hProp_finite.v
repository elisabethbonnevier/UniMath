Require Import UniMath.Algebra.Lattice.
Require Import UniMath.Combinatorics.StandardFiniteSets.
Require Import UniMath.Combinatorics.FiniteSets.
Require Import UniMath.Foundations.Propositions.
Require Import UniMath.MoreFoundations.Propositions.
Require Import UniMath.MoreFoundations.Subtypes.


(* Free bounded distributive lattice generated by a finite set. Thus all subsets are finite. *)
(* NOTE: In the construction below, X is assumed to be finite. *)


(* A free bounded distributive lattice is a distributive lattice with 0 and 1 that is freely generated by a set. *)
(* Distributivity of two binary operations defined in UniMath.Algebra.BinaryOperations. as isrdistr/isldistr/isdistr *)
(* Subsets defined in MoreFoundations/Sets *)

(** Free bounded distributive lattice on a finite set of generators.
We define it as finite irredundant sets of finite subsets of the generators.
Join is union and then removing redundant sets.
Meet is pairwise union and then removing redundant sets.
See https://en.wikipedia.org/wiki/Distributive_lattice#Free_distributive_lattices. *)

(* 0 is the empty join. *)
(* 1 is the empty meet. *)

Open Scope stn.
Open Scope subtype.
Open Scope logic.


Section fbdl.

Declare Scope fbdl.

(* Powerset *)
Notation "'ℙ' X" := (hsubtype X) (at level 10).

(* There is a coercion "carrier" that sends A : hsubtype X to the sigma-type ∑ (x : A) A(x). *)
(* We use the notation |_| to get the underlying type of the carrier of hsubtype. *)
Notation "| S |" := (pr1 S) (at level 10).

Definition is_fbdl_element {X : UU} (P : ℙ (ℙ X)) : hProp :=
  (∀ (T S : P), |T| ⊆ |S| ⇒ |T| ≡ |S|).

Definition fbdl_elements (X : UU) : hSet.
Proof.
  use make_hSet.
  - exact (∑ P : ℙ (ℙ X), is_fbdl_element P).
  - apply isaset_total2.
    + apply isasethsubtype.
    + intro P.
      apply isasetaprop.
      exact (pr2 (is_fbdl_element P)).
Defined.

Notation "⟨ X ⟩" := (fbdl_elements X) (at level 9).

Definition remove_redundant_sets {X : UU} (P : ℙ (ℙ X)) : ⟨ X ⟩.
Proof.
  use tpair.
  - intro S.
    exact ((((S ,, tt) : ∑ (_ : ℙ X), htrue) ∈ P) ∧ (∀ (T : P), |T| ⊆ S ⇒ |T| ≡ S)).
  - intros S S' SsubS' x.
    split.
    + exact (SsubS' x).
    + destruct S as [S [SinP Snotredundant]].
      destruct S' as [S' [S'inP S'notredundant]].
      apply (@dirprod_pr2 (S x → S' x) _).
      generalize x.
      exact (S'notredundant (S,, SinP) SsubS').
Defined.

Definition binary_union {X : UU} (P Q : ℙ X) : ℙ X :=
  λ x, P x ∨ Q x.

Notation "P ∪ Q" := (binary_union P Q) (at level 11).

Lemma iscomm_binary_union {X : UU} : iscomm (@binary_union X).
Proof.
  intros P Q.
  apply funextfun; intro x.
  use hPropUnivalence; apply islogeqcommhdisj.
Defined.

Lemma islogeqassochdisj {A B C : UU} : (A ∨ B) ∨ C <-> A ∨ (B ∨ C).
Proof.
  unfold hdisj.
  split; intros is P f; set (isP := is P).
  - assert (g : ∥ A ⨿ B ∥ ⨿ C → P).
    { apply sumofmaps.
      + apply hinhuniv.
        apply sumofmaps.
        * exact (f ∘ inl).
        * exact (f ∘ inr ∘ hinhpr ∘ inl).
      + exact (f ∘ inr ∘ hinhpr ∘ inr). }
    exact (isP g).
  - assert (g : A ⨿ ∥ B ⨿ C ∥ → P).
    { apply sumofmaps.
      + exact (f ∘ inl ∘ hinhpr ∘ inl).
      + apply hinhuniv.
        apply sumofmaps.
        * exact (f ∘ inl ∘ hinhpr ∘ inr).
        * exact (f ∘ inr). }
    exact (isP g).
Defined.

Lemma isassoc_binary_union {X : UU} : isassoc (@binary_union X).
Proof.
  intros P Q R.
  apply funextfun; intro x.
  unfold binary_union.
  use hPropUnivalence; apply islogeqassochdisj.
Defined.

Definition fbdl_join {X : UU} : binop ⟨ X ⟩ :=
  λ P Q, remove_redundant_sets (|P| ∪ |Q|).

Definition pointwise_union {X : UU} (P Q : ℙ (ℙ X)) : (ℙ (ℙ X)) :=
  λ S, ∃ (T : P) (T' : Q), (S ≡ |T| ∪ |T'|).

Notation "P ⊍ Q" := (pointwise_union P Q) (at level 11).

Lemma iscomm_pointwise_union {X : hSet} : iscomm (@pointwise_union X).
Proof.
  intros P Q.
  apply funextfun; intro S.
  unfold pointwise_union.
  apply hPropUnivalence;
    apply hinhfun;
    intros [T [T' p]];
    exists T'; exists T;
    rewrite (iscomm_binary_union (|T'|) (|T|));
    exact p.
Defined.

Lemma isassoc_pointwise_union {X : hSet} : isassoc (@pointwise_union X).
Proof.
  intros P Q R.
  apply funextfun; intro S.
  unfold pointwise_union.
  use hPropUnivalence.
  - intro ex.
    intro A.
    intro f.
    set (exA := ex A).
    assert (g : (∑ (T : ∑ S : ℙ X, ∃ (T : P) (T' : Q), S ≡ |T| ∪ |T'|) (T' : R), S ≡ |T| ∪ |T'|) → A).
Admitted.

Definition fbdl_meet {X : UU} : binop ⟨ X ⟩ :=
  λ P Q, remove_redundant_sets (|P| ⊍ |Q|).


(* Distributive lattices *)

Definition distributive_latticeop {X : hSet} (l : lattice X) :=
  isldistr (Lmax l) (Lmin l).

Definition distributive_lattice (X : hSet) :=
  ∑ (l : lattice X), distributive_latticeop l.

Definition bounded_distributive_lattice (X : hSet) :=
  ∑ (l : lattice X) (bot top : X), (bounded_latticeop l bot top) × (distributive_latticeop l).



(* Free bounded distributive lattice on a set of generators *)

Lemma assoc_meet_lemma {X : UU} (P Q : ℙ (ℙ X)) :
  remove_redundant_sets (|remove_redundant_sets P| ⊍ Q) = remove_redundant_sets (P ⊍ Q).
Admitted.

Lemma isassoc_fbdl_meet {X : hSet} : isassoc (@fbdl_meet X).
Proof.
  intros P Q R.
  unfold fbdl_meet.
  rewrite assoc_meet_lemma.
  rewrite isassoc_pointwise_union.
  rewrite iscomm_pointwise_union.
  rewrite <- assoc_meet_lemma.
  rewrite iscomm_pointwise_union.
  apply idpath.
Defined.

Lemma iscomm_fbdl_meet {X : hSet} : iscomm (@fbdl_meet X).
Proof.
  intros P Q.
  unfold fbdl_meet.
  rewrite iscomm_pointwise_union.
  apply idpath.
Defined.

Lemma assoc_join_lemma {X : UU} (P Q : ℙ (ℙ X)) :
  remove_redundant_sets (|remove_redundant_sets P| ∪ Q) = remove_redundant_sets (P ∪ Q).
Admitted.

Lemma isassoc_fbdl_join {X : hSet} : isassoc (@fbdl_join X).
Proof.
  intros P Q R.
  unfold fbdl_join.
  rewrite assoc_join_lemma.
  rewrite isassoc_binary_union.
  rewrite iscomm_binary_union.
  rewrite <- assoc_join_lemma.
  rewrite iscomm_binary_union.
  apply idpath.
Defined.

Lemma iscomm_fbdl_join {X : hSet} : iscomm (@fbdl_join X).
Proof.
  intros P Q.
  unfold fbdl_join.
  rewrite iscomm_binary_union.
  apply idpath.
Defined.

Lemma fbdl_absorption_1 {X : hSet} : ∏ x y : fbdl_elements X, fbdl_meet x (fbdl_join x y) = x.
Proof.
  intros P Q.
  unfold fbdl_meet.
  unfold fbdl_join.
  rewrite iscomm_pointwise_union.
  rewrite assoc_meet_lemma.
Admitted.

Lemma fbdl_absorption_2 {X : hSet} : ∏ x y : fbdl_elements X, fbdl_join x (fbdl_meet x y) = x.
Proof.
  intros P Q.
  unfold fbdl_meet.
  unfold fbdl_join.
  rewrite iscomm_binary_union.
  rewrite assoc_join_lemma.
Admitted.

Definition free_bounded_distributive_lattice (X : hSet) : lattice (fbdl_elements X).
Proof.
  use mklattice.
  - exact fbdl_meet.
  - exact fbdl_join.
  - repeat split.
    + apply isassoc_fbdl_meet.
    + apply iscomm_fbdl_meet.
    + apply isassoc_fbdl_join.
    + apply iscomm_fbdl_join.
    + apply fbdl_absorption_1.
    + apply fbdl_absorption_2.
Defined.
